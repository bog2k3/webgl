import { Entity } from "../joglfw/world/entity";
import { IUpdatable } from "../joglfw/world/updateable";
import { World } from "../joglfw/world/world";
import { WebSock } from "../websock";
import { CNetworkEntityCreatedDTO, SNetworkEntityCreatedDTO } from "./dto/network-entity-created.dto";
import { INetworkSerializable } from "./network-serializable";

const NETWORK_UPDATE_TIME = 0.1; // sec

export class NetworkEntityManager implements IUpdatable {
	constructor() {
		this.setupHandlers();
	}

	addEntityFactory(entType: string, factoryFn: () => Entity & INetworkSerializable): void {
		this.entityFactory[entType] = factoryFn;
	}

	update(dt: number): void {
		for (let w of this.localEntities) {
			w.updateTimer += dt;
			if (w.updateTimer > NETWORK_UPDATE_TIME) {
				w.updateTimer -= NETWORK_UPDATE_TIME;
				this.sendLocalEntityUpdate(w.entity);
			}
		}
	}

	addLocalEntity(ent: Entity & INetworkSerializable): void {
		const wrapper = new LocalEntityWrapper(ent);
		this.sendLocalEntityCreated(ent).then((networkId: number) => {
			wrapper.networkId = networkId;
			this.localEntities.push(wrapper);
		});
	}

	removeLocalEntity(ent: Entity & INetworkSerializable): void {
		this.sendLocalEntityDestroyed(ent);
		this.localEntities.splice(
			this.localEntities.findIndex((w) => w.entity === ent),
			1,
		);
	}

	// ----------------- PRIVATE AREA --------------------//
	nextInterimNetworkId = 1;
	localEntities: LocalEntityWrapper[] = [];
	remoteEntities: { [networkId: number]: Entity & INetworkSerializable } = {};
	pendingIdResolution: { [interimId: number]: (number) => void } = {};
	entityFactory: { [entityType: string]: () => Entity & INetworkSerializable } = {};

	setupHandlers(): void {
		WebSock.onEntityCreated.add((payload) => this.addNetworkEntity(payload));
		WebSock.onEntityUpdated.add((payload) => this.updateNetworkEntity(payload));
		WebSock.onEntityDestroyed.add((payload) => this.removeNetworkEntity(payload));
		WebSock.onNetworkEntityIdResolved.add((payload) => this.resolveNetworkId(payload));
	}

	resolveNetworkId(data: { interim: number; resolved: number }): void {
		if (!this.pendingIdResolution[data.interim]) {
			console.warn(`Received network entity id resolution for unknown interimId: ${data.interim}.`);
			return;
		}
		this.pendingIdResolution[data.interim](data.resolved);
		delete this.pendingIdResolution[data.interim];
	}

	addNetworkEntity(data: SNetworkEntityCreatedDTO): void {
		if (!this.entityFactory[data.entityType]) {
			throw new Error(`No known factory for entity type "${data.entityType}"`);
		}
		const ent: Entity & INetworkSerializable = this.entityFactory[data.entityType]();
		ent.getTransform().setPosition(data.position);
		ent.getTransform().setOrientation(data.orientation);
		ent.setNWAttributes(data.attributes);
		this.remoteEntities[data.networkId] = ent;
		World.getInstance().addEntity(ent);
	}

	updateNetworkEntity(data: SNetworkEntityUpdatedDTO): void {}

	removeNetworkEntity(data: SNetworkEntityDestroyedDTO): void {}

	/** @returns the networkId generated by the server for the entity */
	sendLocalEntityCreated(ent: Entity & INetworkSerializable): Promise<number> {
		return new Promise((resolve) => {
			const interimId = this.nextInterimNetworkId;
			this.pendingIdResolution[this.nextInterimNetworkId++] = resolve;
			WebSock.sendEntityCreated(<CNetworkEntityCreatedDTO>{
				interimNetworkId: interimId,
				entityType: ent.getType(),
				position: ent.getTransform().position(),
				orientation: ent.getTransform().orientation(),
				attributes: ent.getNWAttributes(),
			});
		});
	}

	sendLocalEntityUpdate(ent: Entity & INetworkSerializable): void {}

	sendLocalEntityDestroyed(ent: Entity & INetworkSerializable): void {}
}

class LocalEntityWrapper {
	entity: Entity & INetworkSerializable;
	networkId: number;
	updateTimer = 0;

	constructor(ent: Entity & INetworkSerializable) {
		this.entity = ent;
	}
}
